"verbose nmap <Leader>w   查看键位的实际映射
"!表示使用shell中的语句 !open可以打开pdf，各种编译器
"当使用ctrlSF时，记得设定project，不然会出错,要记得ctrlSF [] {path}语句
"或者必须要使用cd语句来引导到当前的working directory
"%  match bucket
"use :edit to exit X mode
set nocompatible              " required
filetype off                  " required
" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
" alternatively, pass a path where Vundle should install plugins
"call vundle#begin('~/some/path/here')
" let Vundle manage Vundle, required
Plugin 'gmarik/Vundle.vim'
" Add all your plugins here (note older versions of Vundle used Bundle instead of Plugin)
"**************************************************
" Track the engine.
" ppets are separated from the engine. Add this if you want them:"
Plugin 'ervandew/supertab' 
Plugin 'gerw/vim-latex-suite'
Plugin 'honza/vim-snippets'
Plugin 'SirVer/ultisnips'
Plugin 'scrooloose/nerdtree'
Plugin 'Xuyuanp/nerdtree-git-plugin'
Plugin 'jistr/vim-nerdtree-tabs'
Plugin 'indentLine.Vim'
"Plugin 'sheerun/vim-polyglot'
Plugin 'vim-python/python-syntax'
Plugin 'dyng/ctrlsf.vim'
Plugin 'majutsushi/tagbar'
"Plugin 'vim-airline/vim-airline'
Plugin 'Lokaltog/vim-powerline'
Plugin 'tmhedberg/SimpylFold'
"Plugin 'vim-airline/vim-airline-themes'
Plugin 'kien/rainbow_parentheses.vim'
Plugin 'ctrlpvim/ctrlp.vim'
Bundle 'terryma/vim-expand-region'
Bundle 'gmarik/vundle'
Bundle 'tpope/vim-fugitive'  
Plugin 'tell-k/vim-autopep8'
"Bundle 'Lokaltog/vim-easymotion'  
Bundle 'rstacruz/sparkup', {'rtp': 'vim/'}  
"Bundle 'thinca/vim-quickrun'
"Bundle 'tpope/vim-rails.git'  
Plugin 'nvie/vim-flake8'
Bundle 'TabBar'
Bundle 'L9'  
Bundle 'valloric/YouCompleteMe'
Bundle 'scrooloose/syntastic'
Bundle 'FuzzyFinder'  
" non-GitHub repos  
Bundle 'git://git.wincent.com/command-t.git'  
" Git repos on your local machine (i.e. when working on your own plugin)  
"Bundle 'file:///Users/gmarik/path/to/plugin'  
" ...  
" All of your Plugins must be added before the following line
call vundle#end()            " required
filetype plugin indent on    " required
filetype on
filetype plugin on
filetype indent on
let g:ctrlsf_debug_mode = 1
"***********************************************************************
"Sometimes it is helpful if your working directory is always the same as the file you are editing. To achieve this, put the following in your vimrc:
autocmd BufEnter * silent! lcd %:p:h
"manuual
nnoremap ,cd :cd %:p:h<CR>:pwd<CR>
"font size
set guifont=Monaco:h13
autocmd FileType python,c,cpp,tex,fortran,ncl noremap <buffer> <Leader><F8> :call Autopep8()<CR>
let g:syntastic_python_checkers = ['php']
"nmap <leader><F6> :SyntasticCheck<CR>
"****Leader************************************************

"Latex syntax conceal
set conceallevel=0
let g:Tex_CompileRule_pdf = 'xelatex -interaction=nonstopmode $*'
let g:Tex_MultipleCompileFormats = 'pdf'
let g:Tex_ViewRuleComplete_pdf = 'open -a Preview $*.pdf &'
"ycm
let g:ycm_python_binary_path = 'python'
			
let g:ag_prg="<custom-ag-path-goes-here> --vimgrep"
"let g:ctrlsf_default_root = 'cwd'
let gLeaderlFold_docstring_preview = 1
" 引入，可以补全系统，以及python的第三方包
let g:ycm_global_ycm_extra_conf = "~/.vim/bundle/YouCompleteMe/cpp/ycm/.ycm_extra_conf.py"
"直接触发自动补全
"
let g:ycm_key_invoke_completion = ''

nnoremap <buffer> <leader>t :call SetTitle()<cr>
nnoremap <buffer> <leader>T :call TitleDet()<cr>

"Syntastic
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
let g:syntastic_tex_checkers = ['lacheck', 'text/language_check']
let g:syntastic_python_checkers = ['pyflakes']

set completeopt=longest,menu	"让Vim的补全菜单行为与一般IDE一致(参考VimTip1228)
autocmd InsertLeave * if pumvisible() == 0|pclose|endif	"离开插入模式后自动关闭预览窗口
inoremap <expr> <CR>       pumvisible() ? "\<C-y>" : "\<CR>"	"回车即选中当前上下左右键的行为 会显示其他信息
inoremap <expr> <Down>     pumvisible() ? "\<C-n>" : "\<Down>"
inoremap <expr> <Up>       pumvisible() ? "\<C-p>" : "\<Up>"
inoremap <expr> <PageDown> pumvisible() ? "\<PageDown>\<C-p>\<C-n>" : "\<PageDown>"
inoremap <expr> <PageUp>   pumvisible() ? "\<PageUp>\<C-p>\<C-n>" : "\<PageUp>"
" 跳转到定义处
nnoremap <leader>j :YcmCompleter GoToDefinitionElseDeclaration<CR>
nnoremap <M><F6> :YcmForceCompileAndDiagnostics<CR>	"force recomile with syntastic
 nnoremap <leader>lo :lopen<CR>	"open locationlist
 nnoremap <leader>lc :lclose<CR>	"close locationlist
"inoremap <leader><leader> <C-x><C-o>
let g:ycm_global_ycm_extra_conf = '~/.vim/data/ycm/.ycm_extra_conf.py'
" 不显示开启vim时检查ycm_extra_conf文件的信息  
let g:ycm_confirm_extra_conf=0
" 开启基于tag的补全，可以在这之后添加需要的标签路径  
let g:ycm_collect_identifiers_from_tags_files=1
"注释和字符串中的文字也会被收入补全
let g:ycm_collect_identifiers_from_comments_and_strings = 0
" 输入第2个字符开始补全
let g:ycm_min_num_of_chars_for_completion=2
" 禁止缓存匹配项,每次都重新生成匹配项
let g:ycm_cache_=0
" 开启语义补全
let g:ycm_seed_identifiers_with_syntax=1	
"在注释输入中也能补全
let g:ycm_complete_in_comments = 1
"在字符串输入中也能补全
let g:ycm_complete_in_strings = 1
" 设置在下面几种格式的文件上屏蔽ycm
let g:ycm_filetype_blacklist = {
      \ 'tagbar' : 1,
      \ 'nerdtree' : 1,
      \}
"autocomplete
let g:ycm_autoclose_preview_window_after_completion=1
let g:ycm_global_ycm_extra_conf = "~/.vim/bundle/YouCompleteMe/cpp/ycm/.ycm_extra_conf.py"
let g:ycm_key_invoke_completion = ''
"custom keys
let mapleader=" "
"
let NERDTreeIgnore=['\.pyc$', '\~$'] "ignore files in NERDTree
"I don't like swap files
set noswapfile
"turn on numbering
set nu
"python with virtualenv support
py << EOF
import os.path
import sys
import vim
if 'VIRTUA_ENV' in os.environ:
  project_base_dir = os.environ['VIRTUAL_ENV']
  sys.path.insert(0, project_base_dir)
  activate_this = os.path.join(project_base_dir,'bin/activate_this.py')
  execfile(activate_this, dict(__file__=activate_this))
EOF
"it would be nice to set tag files by the active virtualenv here
set tags=~/mytags "tags for ctags and taglist
"omnicomplete
"autocmd FileType python set =pythoncomplete#Complete
"------------Start Python PEP 8 stuff----------------
" Number of spaces that a pre-existing tab is equal to.
au BufRead,BufNewFile *py,*pyw,*.c,*.h set tabstop=4
"spaces for indents
au BufRead,BufNewFile *.py,*pyw set shiftwidth=4
au BufRead,BufNewFile *.py,*.pyw set expandtab
au BufRead,BufNewFile *.py set softtabstop=4
" Use the below highlight group when displaying bad whitespace is desired.
highlight BadWhitespace ctermbg=red guibg=red
" Display tabs at the beginning of a line in Python mode as bad.
au BufRead,BufNewFile *.py,*.pyw match BadWhitespace /^\t\+/
" Make trailing whitespace be flagged as bad.
au BufRead,BufNewFile *.py,*.pyw,*.c,*.h match BadWhitespace /\s\+$/
" Wrap text after a certain number of characters
au BufRead,BufNewFile *.py,*.pyw, set textwidth=100
" Use UNIX (\n) line endings.
au BufNewFile *.py,*.pyw,*.c,*.h set fileformat=unix
" Set the default file encoding to UTF-8:
set encoding=utf-8
" Keep indentation level from previous line:
autocmd FileType python set autoindent
" make backspaces more powerfull
set backspace=indent,eol,start
"Folding based on indentation:
autocmd FileType python set foldmethod=indent
"use space to open folds
nnoremap <space> za 
nnoremap <buffer> <leader>e :call EvinceNearestLabel()<CR>
nmap <leader><F6> :SyntasticCheck<CR>
"人生经验，之前的全都被space覆盖，所以之后就把它们加在后面
"
"----------Stop python PEP 8 stuff--------------
"js stuff"
autocmd FileType javascript setlocal shiftwidth=2 tabstop=2
"*********************************************************
"filetype plugin indent on 
let g:pydiction_location = '~/.vim/tools/pydiction/complete-dict'
let g:indentLine_char='┆'
let g:indentLine_enabled = 1 
let g:autopep8_disable_show_diff=1
let g:airline_powerline_fonts = 1
let g:airline_theme="badwolf"
set go=             " 不要图形按钮  
"autocmd InsertLeave * se nocul
"autocmd InsertEnter * se cul
set showcmd         " 输入的命令显示出来，看的清楚些  
set novisualbell    " 不要闪烁(不明白)  
set laststatus=1	" 启动显示状态行(1),总是显示状态行(2)  
set foldenable      " 允许折叠  
set foldcolumn=1
set foldmethod=indent 
set foldlevel=99 
set background=dark "背景使用黑色 
set nocompatible	"去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限
"set nu				"show line number
set helplang=cn
set fileencodings=utf-8,gb2312,gbk,gb18030
set termencoding=utf-8
set encoding=utf-8
set autoread
"set completeopt=preview,menu 
set completeopt=longest,menu
set clipboard+=unnamed 
set nobackup
set autowrite
set ruler                 " 打开状态栏标尺
set cursorline              " 突出显示当前行
set magic                   " 设置魔术
set guioptions-=T           " 隐藏工具栏
set guioptions-=m           " 隐藏菜单栏
set syntax=on
set noeb
set confirm
set autoindent
set cindent
set tabstop=4
set softtabstop=4
set shiftwidth=4
set noexpandtab
set smarttab
set history=1000
set noswapfile
set ignorecase
set hlsearch
set incsearch
set viminfo+=!
set iskeyword+=_,$,@,%,#,-
set linespace=0
set wildmenu
set whichwrap+=<,>,h,l
set selection=exclusive
set selectmode=mouse,key
set report=0
set fillchars=vert:\ ,stl:\ ,stlnc:\
set showmatch
set matchtime=3
set smartindent
set ma
"autocmd FileType python set =pythoncomplete#Complete
autocmd FileType y map <buffer> <leader><space> :w<cr>:make<cr>
au BufRead,BufNewFile *.ncl set filetype=ncl
au BufRead,BufNewFile *.tex set filetype=tex
au! Syntax newlang source $VIM/ncl.vim
au BufRead,BufNewFile *  setfiletype txt
autocmd BufNewFile *.tex,*.cpp,*.[ch],*.sh,*.py,*.java,*.ncl exec ":call SetTitle()" 
:inoremap ( ()<ESC>i
:inoremap ) <c-r>=ClosePair(')')<CR>
:inoremap { {}<ESC>i
:inoremap } <c-r>=ClosePair('}')<CR>
:inoremap [ []<ESC>i
:inoremap ] <c-r>=ClosePair(']')<CR>
function! ClosePair(char)
	if getline('.')[col('.') - 1] == a:char
		return "\<Right>"
	else
		return a:char
	endif
endfunction
function!  SetTitle() 
		if &filetype == 'sh' 
		call setline(1,"\#!/bin/bash") 
		call append(line("."), "\#########################################################################") 
		call append(line(".")+1, "\#File Name: ".expand("%"))
		call append(line(".")+2, "\# Author:  Tiangang Zhou") 
		call append(line(".")+3, "\# mail: tg_zhou@pku.edu.cn") 
		call append(line(".")+4, "\#########################################################################") 
		call append(line(".")+5, "") 
		call append(line(".")+6, "") 
	elseif &filetype=='python' 
		call setline(1, "\#!\/anaconda\/bin\/python3.6")
		call append(line("."), "##-*-coding:utf-8 -*-")
		call append(line(".")+1, "\#########################################################################") 
		call append(line(".")+2, "\#	 File Name   :  ".expand("%")) 
		call append(line(".")+3, "\#	 author      :   Tiangang Zhou") 
		call append(line(".")+4, "\#	 e-Mail      :  tg_zhou@pku.edu.cn ") 
		call append(line(".")+5, "\#     created at  :  ".strftime("%Y-%m-%d %H:%M"))
		call append(line(".")+6, "\#     purpose     :  ")
		call append(line(".")+7, "\#########################################################################") 
		call append(line(".")+8, "")
		call append(line(".")+9, "")
		call append(line(".")+10, "import numpy as np")
		call append(line(".")+11, "import matplotlib.pyplot as plt")
		call append(line(".")+12, "")
		call append(line(".")+13, "")
		call append(line(".")+14, "")
		call append(line(".")+15, "if __name__==\"__main__\":")
		call append(line(".")+16, "    filename=\"\.\/data\"")
		call append(line(".")+17, "    data=np.load(filename)[()]")
		call append(line(".")+18, "    detail(data)")
		call append(line(".")+19, "")
	elseif &filetype=='tex'
		call setline(1, "\%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%") 
		call append(line("."),"\%	 all right is reserved for Tiangang Zhou")
		call append(line(".")+1, "\%	 File Name   :  ".expand("%")) 
		call append(line(".")+2, "\%	 author      :  Tiangang Zhou") 
		call append(line(".")+3, "\%	 e-Mail      :  tg_zhou@pku.edu.cn ") 
		call append(line(".")+4, "\%    created at  :  ".strftime("%Y-%m-%d %H:%M"))
		call append(line(".")+5, "\%    purpose     :  ")
		call append(line(".")+6, "\%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%") 
		call append(line(".")+7, "")
		call append(line(".")+8, "\\documentclass{article}")
		call append(line(".")+9,"\\usepackage{siunitx}")
		call append(line(".")+10,"\\usepackage{graphicx}")
		call append(line(".")+11,"\\usepackage{booktabs}")
		call append(line(".")+12, "\\usepackage[UTF8]{ctex}")
		call append(line(".")+13, "\\usepackage{lastpage}")
		call append(line(".")+14, "\\usepackage{geometry}")
		call append(line(".")+15, "\\usepackage{amsmath}")
		call append(line(".")+16, "\\geometry{left=3.18cm,right=3.18cm,top=2.54cm,bottom=2.54cm}")
		call append(line(".")+17, "\\usepackage[font=small,labelfont=bf]{caption}") 
		call append(line(".")+18, "\\begin{document}")
		call append(line(".")+19, "\\title{}")
		call append(line(".")+20, "\\author{周天罡}")
		call append(line(".")+21, "\\maketitle")
		call append(line(".")+22, "")
		call append(line(".")+23, "\\section{your section}")
		call append(line(".")+24, "")
		call append(line(".")+25, "% /\ subsection{you subsection}")
		call append(line(".")+26, "% /\ begin{figure}[htbp]")
		call append(line(".")+27, "% /\ centering")
		call append(line(".")+28, "% /\ resizebox{15cm}{6cm}{includegraphics{pic path}}")
		call append(line(".")+29, "% /\ caption{youcaption}\label{fig:fig5}")
		call append(line(".")+30, "% /\ end{figure}")
		call append(line(".")+31, "")
		call append(line(".")+32, "\\end{document}")
	endif
	autocmd BufNewFile * normal G
endfunc 
nmap <leader>w :w!<cr>
nmap <leader>f  :find<cr>
vmap <C-c> "+y
map! <C-A> <Esc>ggVGY
map <C-A> ggVGY
map <M-F2> :tabnew<CR>  
map <C-F3> \be  
"map <F8> :tabnew .<CR>  
map <C-h> gg=G
map <F9> :Tagbar<CR>
map ff <Plug>CtrlSFPrompt
map F <Plug>CtrlSFQuickfixPrompt
map <silent> <F2> :call AddFirstSingleComments()<CR>  
nnore map <C-F2> :vert diffsplit 
nnoremap <F6> :g/^\s*$/d<CR> 
function! AddFirstSingleComments()  
    if &filetype == 'sh'  
        :.,+0 s/^/#/  
    elseif &filetype == 'fortran'  
        :.,+0 s/^/!/  
    elseif &filetype == 'c'  
        :.,+0 s#^#//#  
    elseif &filetype == 'cpp'  
		:.,+0 s#^#//#  
    elseif &filetype == 'ncl'  
        :.,+0 s#^#;#  
    elseif &filetype == 'tex'  
        :.,+0 s#^#%#g  
    elseif &filetype == 'python'  
        :.,+0 s/^/#/  
    else  
        :.,+0 s/^/#/  
    endif  
endfunction
map <silent> <F3> :call RemoveFirstSingleComments()<CR>  
function! RemoveFirstSingleComments()  
    if &filetype == 'sh'  
        :.,+0 s/^#//  
    elseif &filetype == 'fortran'  
        :.,+0 s/^!/ /  
    elseif &filetype == 'c'  
        :.,+0 s#^//##
    elseif &filetype == 'ncl'  
        :.,+0 s#^;##  
    elseif &filetype == 'cpp'  
        :.,+0 s#^//##  
    elseif &filetype == 'tex'  
        :.,+0 s/^%//  
    elseif &filetype == 'python'  
        :.,+0 s/^#//  
    else  
        :.,+0 s/^#//  
    endif  
endfunction  
colorscheme ron  
"按<F4>键依次修改颜色主题  
map <F4> :call ChangeColorScheme()<CR>
let g:csnum = 0
function! ChangeColorScheme()  
	if g:csnum == 0  
		:colorscheme elflord 
		:let g:csnum = 1  
	elseif  g:csnum == 1  
		:colorscheme murphy  
		:let g:csnum = 2  
	elseif  g:csnum == 2
		:colorscheme desert
		:let g:csnum = 3
	elseif  g:csnum == 3
		:colorscheme torte
		:let g:csnum = 4
	elseif  g:csnum == 4
		:colorscheme koehler
		:let g:csnum = 5
	elseif  g:csnum == 5
		:colorscheme delek
		:let g:csnum = 6
	elseif  g:csnum == 6
		:colorscheme ron
		:let g:csnum = 7
	elseif  g:csnum == 7
		:colorscheme default
		:let g:csnum = 8
	else  
        :colorscheme evening 
        :let g:csnum = 0  
	endif  
endfunction
map <F5> :call CompileRunGcc()<CR>
func! CompileRunGcc()
	exec "w"
	if &filetype == 'c'
		exec "!g++ % -o %<"
		exec "! ./%<"
	elseif &filetype == 'cpp'
		exec "!g++ % -o %<"
		exec "! ./%<"
	elseif &filetype == 'java' 
		exec "!javac %" 
		exec "!java %<"
	elseif &filetype == 'sh'
		:!./%
	elseif &filetype == 'python'
		"exec "!/anaconda/bin/python3.6 %"
		exec "!python3 %"
	elseif &filetype == 'fortran'
		exec "!gfortran % -o %<"
		exec "! ./%<"
	elseif &filetype == 'ncl'
		exec "!ncl %"
	elseif &filetype == 'tex'
		exec "!xelatex %"
		"exec ""!latexm
		exec "!open %:r.pdf"
	else
		exec "!source %"
	endif
endfunc
func! RunPython()
	let mp = &makeprg
	let ef = &errorformat
	let exeFile = expand("%:t")
	setlocal makeprg=python\ -u
	set efm=%C\ %.%#,%A\ \ File\ \"%f\"\\,\ line\ %l%.%#,%Z%[%^\ ]%\\@=%m
	silent make %
	copen
	let &makeprg = mp
	let &errorformat = ef
endfunction
"NERDtee设定
let NERDChristmasTree=1
let NERDTreeAutoCenter=1
let NERDTreeBookmarksFile=$VIM.'\Data\NerdBookmarks.txt'
let NERDTreeMouseMode=2
let NERDTreeShowBookmarks=1
let NERDTreeShowFiles=1
let NERDTreeShowHidden=1
let NERDTreeShowLineNumbers=1
let NERDTreeWinPos='left'
let NERDTreeWinSize=25
let g:tagbar_width=20
let NERDTreeIgnore=['\.pyc$']
"nnoremap f :NERDTreeToggle
map <F8> :NERDTreeToggle<CR> 
"map <> :call SaveInputData()<CR>                                                                          
set splitbelow
set splitright
nnoremap <C-J> <C-W> <C-J>
nnoremap <C-K> <C-W> <C-K>
nnoremap <C-L> <C-W> <C-L>
nnoremap <C-H> <C-W> <C-H>
func! SaveInputData()
	exec "tabnew"
	exec 'normal "+gP'
	exec "w! /tmp/input_data"
	endfunc
let g:rbpt_colorpairs = [ ['brown', 'RoyalBlue3'], ['Darkblue', 'SeaGreen3'], ['darkgray', 'DarkOrchid3'], ['darkgreen', 'firebrick3'],['darkcyan', 'RoyalBlue3'],['darkred', 'SeaGreen3'],['darkmagenta', 'DarkOrchid3'],['brown', 'firebrick3'],['gray', 'RoyalBlue3'],['black',       'SeaGreen3'],['darkmagenta', 'DarkOrchid3'],['Darkblue',  'firebrick3'],['darkgreen', 'RoyalBlue3'],['darkcyan', 'SeaGreen3'],['darkred', 'DarkOrchid3'],['red', 'firebrick3']]
let g:rbpt_max = 16
au VimEnter * RainbowParenthesesToggle
au Syntax * RainbowParenthesesLoadRound
au Syntax * RainbowParenthesesLoadSquare
au Syntax * RainbowParenthesesLoadBraces
" winmanager"
let g:winManagerWindowLayout='NERDTree|Tagbar'
let g:winManagerWidth=30
let g:AutoOpenWinManager = 1 "这里要配合修改winmanager.vim文件，见下方说明"
function! UpdateTitle()
    normal m'
    execute '/# *Last modified:/s@:.*$@\=strftime(":\t%Y-%m-%d %H:%M")@'
    normal ''
    normal mk
    execute '/# *Filename:/s@:.*$@\=":\t\t".expand("%:t")@'
    execute "noh"
    normal 'k
    echohl WarningMsg | echo "Successful in updating the copy right." | echohl None
endfunction
"判断前10行代码里面，是否有Last modified这个单词，
"如果没有的话，代表没有添加过作者信息，需要新添加；
"如果有的话，那么只需要更新即可
function! TitleDet()
    let n=1
    "默认为添加
    while n < 10
        let line = getline(n)
        if line =~ '^\#\s*\S*Last\smodified:\S*.*$'
            call UpdateTitle()
            return
        endif
        let n = n + 1
    endwhile
    call AddTitle()
endfunction
vmap v <Plug>(expand_region_expand)
vmap <C-v> <Plug>(expand_region_shrink)
noremap <CR> G
noremap <BS> g
let g:winManagerWindowLayout='FileExplorer|TagList'
noremap wm :WMToggle
set tags=/home/gangz/pylib/tags,/home/gangz/local/Enthought/User/lib/python2.7/site-packages/tags,/home/gangz/work/tags
set cursorline
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>
let g:SimpylFold_docstring_preview=1
let python_highlight_all=1
syntax on
let g:autopep8_disable_show_diff=1
set number
set relativenumber
inoremap jj <ESC> 
nmap <leader>w :w<CR>
nmap <leader>q :q<CR>
nmap <leader>wq :wq<CR>
nmap gh ^
nmap gl $
vmap gh ^
vmap gl $
autocmd BufWritePost $MYVIMRC source $MYVIMRC
ab iopt from cpac.optics import 
ab ipnsd from cpac.PNSD import
ab imath from cpac.math import
ab itool from cpac.tools import 
ab icoreshell from coacp.optices import coreshell,internal,exteranl
ab iexternal from coacp.optices import coreshell,internal,exteranl
ab iinternal from coacp.optices import coreshell,internal,exteranl
ab ipf from cpac.optics import PFs_PNSD
ab ibcpmsd from cpac.optics import Get_BCpvsd_YF
ab ibounds from cpac.PNSD import Get_Dps_bounds
ab iangstrom from cpac.BC import angstrom
ab ismooth from cpac.math import smooth
ab ilineregress from cpac.math import lineregress
ab igetdatafromjul from uselib.math import getDataFromJul
ab ijul2date from uselib.time import jul2date
ab idate2jul from uselib.time import date2ju:l
ab iselect from uselib.tools import selectData
let g:quickrun_config = {
			\   "_" : {
			\       "outputter" : "message",
			\   },
			\}
let g:quickrun_no_default_key_mappings = 1
nmap <Leader>r <Plug>(quickrun)
map <F10> :QuickRun<CR>
Bundle 'vim-scripts/matchit.zip'
"autocomplet:
let g:ycm_autoclose_preview_window_after_completion=1


"Ultisnips YCM
" make YCM compatible with UltiSnips (using supertab)
let g:ycm_key_list_select_completion = ['<C-n>', '<Down>']
let g:ycm_key_list_previous_completion = ['<C-p>', '<Up>']
let g:SuperTabDefaultCompletionType = '<C-n>'
" better key bindings for UltiSnipsExpandTrigger
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger="<S-tab>"
